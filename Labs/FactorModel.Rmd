---
title: "Latent Factors"
output: html_document
date: "2023-10-12"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# TO DO:

-   Write out model
-   Simulate data and code Nimble model
-   Can I get it to work without k?
-   Figure out conjugacy - maybe make that an exercise. 
-   Add polyga gamma
-   Evaluate performance
-   Add cross validation


```{r, echo = FALSE, message = FALSE}
## Set directories
data_path <- 'Data/'
save_path <- 'Results/'

# Load packages
library(tidyverse)
library(here)
library(igraph)
library(ggraph)
library(RColorBrewer)
library(pheatmap)
library(nimble)
library(nimbleHMC)
library(bayesplot)
library(mvtnorm)
library(gridExtra)

# Do we want to save any output?
save_files <- TRUE

```

First, we simulate data from an inner product graph model

```{r}
set.seed(1234)

V <- 50 # 5 for simple example
H <- 10
k <- 2
a1 <- 2
a2 <- 2 # Note: this is pretty strong shrinkage, 2 usually works well

# Simulate from shrinkage process
U <- rep(NA,H)
U[1] <- rgamma(1, a1, 1)
U[2:H] <- rgamma(H-1, a2, 1)

Tau <- rep(NA, H)
for(h in 1:H){
  Tau[h] <- prod(U[1:h])
}

# Simulate latent factors
X <- matrix(NA, nrow = V, ncol = H)
for(h in 1:H){
  X[,h] <- rmvnorm(n = 1, mean = rep(0, V), sigma = diag(k*Tau[h]^(-1), nrow = V)) 
}

# Simulate intercept
meanP <- 0.25
mu0 <- log(meanP/(1-meanP))
mu <- rnorm(1,mean = mu0, sd = 1)

# Compute the linear predictor and probability matrix
S <- mu + X %*% t(X)
P <- (1 + exp(-S))^(-1)
diag(P) <- NA

# Sample edges
Y <- matrix(NA, V,V)
Y[upper.tri(Y)] <- rbinom(V*(V-1)/2, 1, P[upper.tri(P)])
Y[lower.tri(Y)] <- t(Y)[lower.tri(Y)]

rownames(Y) <- colnames(Y) <- rownames(P) <- colnames(P) <- LETTERS[1:V]

p1 <- pheatmap(P, cluster_rows = FALSE, cluster_cols = FALSE, 
         color=colorRampPalette(brewer.pal(9,"Blues")[c(1,8)])(30), 
         main = "Probability Matrix")[[4]]

p2 <- pheatmap(Y, cluster_rows = FALSE, cluster_cols = FALSE, 
         color=colorRampPalette(brewer.pal(9,"Blues")[c(1,8)])(30), 
         main = "Adjacency Matrix")[[4]]

p3 <- data.frame(LF1 = X[, 1], LF2 = X[,2], id = LETTERS[1:V]) %>% 
ggplot(aes(x = LF1, y = LF2, label = id)) + 
  geom_text() + 
  theme_minimal() + 
  ggtitle("Latent Space") + 
  theme(plot.title = element_text(hjust = 0.5))

grid.arrange(p1, p2, p3,  nrow = 1)


```

```{r, echo = FALSE}
# Define model with BUGS code
fmCode <- nimbleCode({
  
  # Intercept
  mu ~ dnorm(mu0, sd = 1)
  
  # Shrinkage process
  U[1] ~ dgamma(a1, 1)
  for(h in 2:H){
    U[h] ~ dgamma(a2, 1)
  }

  for(h in 1:H){
    Tau[h] <- prod(U[1:h])
  }

  # Latent factors
  for(h in 1:H){
    mvCov[1:V, 1:V, h] <- k*Tau[h]^(-1)*diag(V) # Array construction to avoid multiply-defined nodes on LHS
    X[,h] ~ dmnorm(M[] , cov = mvCov[1:V,1:V, h]) 
  }
  
  # Compute linear predictor
  S[1:V,1:V] <- mu + X[,] %*% t(X[,]) # Recall multivariate nodes must be used with []
  P[1:V,1:V] <- (1 + exp(-S[1:V,1:V]))^(-1)
  #diag(P[1:V, 1:V]) <- rep(0,V) # Should not matter since likelihood excludes Y[i,i]

  # Likelihood
  for (i in 2:V){
    for (j in 1:(i-1)){ # Self-edges not allowed
      Y[i,j] ~ dbin(size = 1, prob = P[i,j])
    }
  }

})


# Define the constants
diag(Y) <- 0 # diag = NA is useful for plotting only
mu0 = log(mean(Y)/(1-mean(Y))) # prior mean for Mu is logit(meanY)

fmConsts <- list(V = V, k = k,
                  a1 = a1, a2 = a2,
                  mu0 = mu0, 
                  M = rep(0, V))

# Define the data
fmData <- list(Y = Y)

# Set initialization parameters
fmInits <- list(P = matrix(mean(Y, na.rm = TRUE), V, V),
                X = matrix(0, V, H), 
                U = 1:H,
                mu = mu0)

fmDims <- list(Tau = H, X = c(V, H), P = c(V,V), S = c(V,V), mvCov = c(V,V,H))

# Create NIMBLE model
fm <- nimbleModel(code = fmCode, name = "fm", constants = fmConsts, data = fmData, 
                   dimensions = fmDims, inits = fmInits)

#fm$plotGraph()

# Check conjugacy
configureMCMC(fm, print = TRUE)

# Easiest way to run: 
niter <- 5000
nchains <- 2
mcmc.out <- nimbleMCMC(code = fmCode, constants = fmConsts,
                       data = fmData, inits = fmInits,
                       nchains = nchains, niter = niter,
                       summary = TRUE, WAIC = TRUE,
                       monitors = c('mu', 'P', 'X', 'Tau')) # We could also include X and investigate distribution of latent factors
```
Evaluate performance

```{r}
head(mcmc.out$summary)
fm.samples <- do.call(rbind, mcmc.out$samples)
p.samples <- fm.samples[, grepl("P", colnames(fm.samples))]

p.post <- matrix(data = colMeans(p.samples), byrow = FALSE, nrow = V, ncol = V)
diag(p.post) <- 0
plot(c(p.post), c(P))


# Not really useful for a single model, but: 
mcmc.out$WAIC

## MCMC diagnostics: unclear how useful because of label switching
fm.samples2 <- mcmc.out$samples

mcmc_trace(fm.samples2, regex_pars = c("mu")) 
mcmc_trace(fm.samples2, regex_pars = c("X")) 
mcmc_trace(fm.samples2, regex_pars = c("Tau")) 

mcmc_intervals(fm.samples2, regex_pars = c("X"))
mcmc_intervals(fm.samples2, regex_pars = c("Tau"))
mcmc_intervals(fm.samples2, pars = paste0("Tau[", 1:5, "]"))

```

Debugging: Tau and X demonstrate appropriate shrinkage at least, Mu is not moving far enough from prior mean,
latent factors aren't able to capture graph structure. So, this is terrible. Let's see if HMC does any better. 

```{r}
# Define R models
HMCmodel <- nimbleModel(code = fmCode, name = "fm", constants = fmConsts, data = fmData, 
                   dimensions = fmDims, inits = fmInits, buildDerivs = TRUE) # we need to enable derivative capabilities for the model 
HMCmcmc <- buildHMC(HMCmodel, 
                    monitors = c("mu", "X", "Tau", "P")) # if we don't supply node names, all non-data nodes will be sampled via HMC
# Compile the C models
Cmodel <- compileNimble(HMCmodel)
Cmcmc <- compileNimble(HMCmcmc, project = HMCmodel)

start.time <- Sys.time()
samplesHMC <- runMCMC(Cmcmc)
Sys.time() - start.time

file_path <- here::here(paste0(save_path, "fmHMC.rds"))
if(save_files){saveRDS(samplesHMC, file_path)}

#samplesHMC <- readRDS(file_path)

# Extract samples and look at them
p.HMC <- samplesHMC[, grepl("P", colnames(samplesHMC))]

p.post.HMC <- matrix(data = colMeans(p.HMC), byrow = FALSE, nrow = V, ncol = V)
diag(p.post.HMC) <- 0
plot(c(p.post.HMC), c(P))
```